import Emittery from 'emittery';
import type { Redis, Cluster } from 'ioredis';
import type { PubSubOptions, ConnectionEvents, PubSubChannelHandler, PubSubPatternHandler } from '../types.js';
/**
 * Abstract factory implements the shared functionality required by Redis cluster
 * and the normal Redis connections.
 */
export declare abstract class AbstractConnection<T extends Redis | Cluster, Events extends ConnectionEvents<any>> extends Emittery<Events> {
    connectionName: string;
    /**
     * Reference to the main ioRedis connection
     */
    ioConnection: T;
    /**
     * Reference to the main ioRedis subscriber connection
     */
    ioSubscriberConnection?: T;
    /**
     * A list of active subscriptions and pattern subscription
     */
    protected subscriptions: Map<string, Set<PubSubChannelHandler>>;
    protected psubscriptions: Map<string, Set<PubSubPatternHandler>>;
    /**
     * The last error emitted by the `error` event. We set it to `null` after
     * the `ready` event
     */
    lastError?: any;
    /**
     * Returns status of the main connection
     */
    get status(): "connect" | "wait" | "end" | "close" | "connecting" | "ready" | "reconnecting" | "disconnecting";
    /**
     * Returns status of the subscriber connection or
     * undefined when there is no subscriber
     * connection
     */
    get subscriberStatus(): "connect" | "wait" | "end" | "close" | "connecting" | "ready" | "reconnecting" | "disconnecting" | undefined;
    /**
     * Get the number of commands queued in automatic pipelines.
     * This is not available (and returns 0) until the cluster is connected and slots information have been received.
     */
    get autoPipelineQueueSize(): number;
    /**
     * Returns a boolean notifying if the connection is
     * in connecting state
     */
    isConnecting(): boolean;
    /**
     * Returns a boolean notifying if the connection is in
     * ready state
     */
    isReady(): boolean;
    /**
     * Returns a boolean notifying if the connection has been closed
     */
    isClosed(): boolean;
    /**
     * Parent class must implement makeSubscriberConnection
     */
    protected abstract makeSubscriberConnection(): void;
    constructor(connectionName: string);
    /**
     * Monitoring the redis connection via event emitter to cleanup
     * things properly and also notify subscribers of this class
     */
    protected monitorConnection(): void;
    /**
     * Monitoring the subscriber connection via event emitter to
     * cleanup things properly and also notify subscribers of
     * this class.
     */
    protected monitorSubscriberConnection(): void;
    /**
     * Setting up the subscriber connection. The method results
     * in a noop when a connection already exists.
     */
    protected setupSubscriberConnection(): void;
    /**
     * Gracefully end the redis connection
     */
    quit(): Promise<void>;
    /**
     * Forcefully end the redis connection
     */
    disconnect(): Promise<void>;
    /**
     * Subscribe to a given channel to receive Redis pub/sub events. A
     * new subscriber connection will be created/managed automatically.
     */
    subscribe(channel: string, handler: PubSubChannelHandler, options?: PubSubOptions): void;
    /**
     * Unsubscribe from a channel
     */
    unsubscribe(channel: string, handler?: PubSubChannelHandler): Promise<unknown>;
    /**
     * Make redis subscription for a pattern
     */
    psubscribe(pattern: string, handler: PubSubPatternHandler, options?: PubSubOptions): void;
    /**
     * Unsubscribe from a given pattern
     */
    punsubscribe(pattern: string, handler?: PubSubPatternHandler): Promise<unknown>;
    /**
     * Publish the pub/sub message
     */
    publish(channel: string, message: string, callback: (error: Error | null | undefined, count: number | undefined) => void): void;
    publish(channel: string, message: string): Promise<number>;
    /**
     * Define a custom command using LUA script. You can run the
     * registered command using the "runCommand" method.
     */
    defineCommand(...args: Parameters<Redis['defineCommand']>): this;
    /**
     * Run a pre registered command
     */
    runCommand(command: string, ...args: any[]): any;
}
