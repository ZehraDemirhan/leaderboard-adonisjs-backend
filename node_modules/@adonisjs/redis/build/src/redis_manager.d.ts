import Emittery from 'emittery';
import type { Logger } from '@adonisjs/core/logger';
import RedisConnection from './connections/redis_connection.js';
import RedisClusterConnection from './connections/redis_cluster_connection.js';
import type { GetConnectionType, IORedisBaseCommands, PubSubChannelHandler, PubSubPatternHandler, RedisConnectionsList } from './types.js';
/**
 * Redis Manager exposes the API to manage multiple redis connections
 * based upon user defined config.
 *
 * All connections are long-lived until they are closed explictly
 */
declare class RedisManager<ConnectionsList extends RedisConnectionsList> extends Emittery<{
    connection: RedisConnection | RedisClusterConnection;
}> {
    #private;
    managerConfig: {
        connection: keyof ConnectionsList;
        connections: ConnectionsList;
    };
    /**
     * Reference to "import('ioredis').Redis.Command"
     */
    Command: typeof import("ioredis").Command;
    /**
     * A copy of live connections. We avoid re-creating a new connection
     * everytime and re-use connections.
     */
    activeConnections: {
        [K in keyof ConnectionsList]?: GetConnectionType<ConnectionsList, K>;
    };
    /**
     * Returns the length of active connections
     */
    get activeConnectionsCount(): number;
    constructor(managerConfig: {
        connection: keyof ConnectionsList;
        connections: ConnectionsList;
    }, logger: Logger);
    /**
     * Disable error logging of redis connection errors. You must
     * handle the errors manually, otheriwse the app will crash
     */
    doNotLogErrors(): this;
    /**
     * Returns redis factory for a given named connection
     */
    connection<ConnectionName extends keyof ConnectionsList>(connectionName?: ConnectionName): GetConnectionType<ConnectionsList, ConnectionName>;
    /**
     * Subscribe to a given channel to receive Redis pub/sub events. A
     * new subscriber connection will be created/managed automatically.
     */
    subscribe(channel: string, handler: PubSubChannelHandler): void;
    /**
     * Unsubscribe from a channel
     */
    unsubscribe(channel: string): Promise<unknown>;
    /**
     * Make redis subscription for a pattern
     */
    psubscribe(pattern: string, handler: PubSubPatternHandler): void;
    /**
     * Unsubscribe from a given pattern
     */
    punsubscribe(pattern: string): Promise<unknown>;
    /**
     * Publish the pub/sub message
     */
    publish(channel: string, message: string, callback: (error: Error | null | undefined, count: number | undefined) => void): void;
    publish(channel: string, message: string): Promise<number>;
    /**
     * Define a custom command using LUA script. You can run the
     * registered command using the "runCommand" method.
     */
    defineCommand(name: string, definition: {
        lua: string;
        numberOfKeys?: number;
        readOnly?: boolean;
    }): this;
    /**
     * Run a pre registered command on the default command
     */
    runCommand(command: string, ...args: any[]): any;
    /**
     * Quit a named connection or the default connection when no
     * name is defined.
     */
    quit<ConnectionName extends keyof ConnectionsList>(name?: ConnectionName): Promise<void>;
    /**
     * Disconnect a named connection or the default connection when no
     * name is defined.
     */
    disconnect<ConnectionName extends keyof ConnectionsList>(name?: ConnectionName): Promise<void>;
    /**
     * Quit all connections
     */
    quitAll(): Promise<void>;
    /**
     * Disconnect all connections
     */
    disconnectAll(): Promise<void>;
}
interface RedisManager<ConnectionsList extends RedisConnectionsList> extends IORedisBaseCommands {
}
export default RedisManager;
