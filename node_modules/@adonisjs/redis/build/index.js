import {
  RedisClusterConnection,
  RedisConnection,
  redis_manager_default
} from "./chunk-HIKRSCG6.js";
import {
  __export
} from "./chunk-PZ5AY32C.js";

// src/errors.ts
var errors_exports = {};
__export(errors_exports, {
  E_INVALID_BYTES_VALUE: () => E_INVALID_BYTES_VALUE,
  E_MULTIPLE_REDIS_PSUBSCRIPTIONS: () => E_MULTIPLE_REDIS_PSUBSCRIPTIONS,
  E_MULTIPLE_REDIS_SUBSCRIPTIONS: () => E_MULTIPLE_REDIS_SUBSCRIPTIONS
});
import { createError } from "@poppinss/utils";
var E_MULTIPLE_REDIS_SUBSCRIPTIONS = createError(
  'Cannot subscribe to "%s" channel. Channel already has an active subscription',
  "E_MULTIPLE_REDIS_SUBSCRIPTIONS",
  500
);
var E_MULTIPLE_REDIS_PSUBSCRIPTIONS = createError(
  'Cannot subscribe to "%s" pattern. Pattern already has an active subscription',
  "E_MULTIPLE_REDIS_PSUBSCRIPTIONS",
  500
);
var E_INVALID_BYTES_VALUE = createError(
  'Invalid bytes value "%s"',
  "E_INVALID_BYTES_VALUE",
  500
);

// stubs/main.ts
import { getDirname } from "@poppinss/utils";
var stubsRoot = getDirname(import.meta.url);

// configure.ts
async function configure(command) {
  const codemods = await command.createCodemods();
  await codemods.makeUsingStub(stubsRoot, "config/redis.stub", {});
  await codemods.defineEnvVariables({
    REDIS_HOST: "127.0.0.1",
    REDIS_PORT: "6379",
    REDIS_PASSWORD: ""
  });
  await codemods.defineEnvValidations({
    variables: {
      REDIS_HOST: `Env.schema.string({ format: 'host' })`,
      REDIS_PORT: "Env.schema.number()",
      REDIS_PASSWORD: "Env.schema.string.optional()"
    }
  });
  await codemods.updateRcFile((rcFile) => {
    rcFile.addProvider("@adonisjs/redis/redis_provider");
  });
}

// src/define_config.ts
import { RuntimeException } from "@poppinss/utils";
function defineConfig(config) {
  if (!config) {
    throw new RuntimeException("Invalid config. It must be an object");
  }
  if (!config.connections) {
    throw new RuntimeException('Missing "connections" property in the redis config file');
  }
  if (!config.connection) {
    throw new RuntimeException(
      'Missing "connection" property in redis config. Specify a default connection to use'
    );
  }
  if (!config.connections[config.connection]) {
    throw new RuntimeException(
      `Missing "connections.${String(
        config.connection
      )}". It is referenced by the "default" redis connection`
    );
  }
  return config;
}

// src/checks/redis_check.ts
import { setTimeout } from "node:timers/promises";
import { BaseCheck, Result } from "@adonisjs/core/health";
var RedisCheck = class extends BaseCheck {
  #connection;
  /**
   * Number of times `ping` was deferred, at max we defer it for 3 times
   */
  #pingAttempts = 0;
  /**
   * Health check public name
   */
  name;
  constructor(connection) {
    super();
    this.#connection = connection;
    this.name = `Redis health check (${connection.connectionName})`;
  }
  /**
   * Returns connection metadata to be shared in the health checks
   * report
   */
  #getConnectionMetadata() {
    return {
      connection: {
        name: this.#connection.connectionName,
        status: this.#connection.status
      }
    };
  }
  /**
   * Internal method to ping the redis server
   */
  async #ping() {
    if (this.#connection.isConnecting() && this.#pingAttempts < 3 && !this.#connection.lastError) {
      await setTimeout(1e3);
      this.#pingAttempts++;
      return this.#ping();
    }
    if (this.#connection.isClosed()) {
      await this.#connection.ioConnection.connect();
      return this.#ping();
    }
    if (!this.#connection.isReady()) {
      return Result.failed(
        "Unable to connect to the redis server",
        this.#connection.lastError
      ).mergeMetaData(this.#getConnectionMetadata());
    }
    await this.#connection.ping();
  }
  /**
   * Executes the health check
   */
  async run() {
    try {
      const result = await this.#ping();
      if (result) {
        return result;
      }
      return Result.ok("Successfully connected to the redis server").mergeMetaData(
        this.#getConnectionMetadata()
      );
    } catch (error) {
      return Result.failed(error).mergeMetaData(this.#getConnectionMetadata());
    }
  }
};

// src/checks/redis_memory_usage_check.ts
import { setTimeout as setTimeout2 } from "node:timers/promises";
import stringHelpers from "@adonisjs/core/helpers/string";
import { BaseCheck as BaseCheck2, Result as Result2 } from "@adonisjs/core/health";
var RedisMemoryUsageCheck = class extends BaseCheck2 {
  #connection;
  /**
   * Number of times `ping` was deferred, at max we defer it for 3 times
   */
  #pingAttempts = 0;
  /**
   * Method to compute the memory consumption
   */
  #computeFn = async (connection) => {
    const memory = await connection.info("memory");
    const memorySegment = memory.split(/\r|\r\n/).find((line) => line.trim().startsWith("used_memory"));
    if (!memorySegment) {
      return null;
    }
    const memoryUsageInBytes = Number(memorySegment.split(":")[1]);
    return Number.isNaN(memoryUsageInBytes) ? null : memoryUsageInBytes;
  };
  /**
   * Memory consumption threshold after which a warning will be created
   */
  #warnThreshold = stringHelpers.bytes.parse("100 mb");
  /**
   * Memory consumption threshold after which an error will be created
   */
  #failThreshold = stringHelpers.bytes.parse("120 mb");
  /**
   * Health check public name
   */
  name;
  constructor(connection) {
    super();
    this.#connection = connection;
    this.name = `Redis memory consumption health check (${connection.connectionName})`;
  }
  /**
   * Returns connection metadata to be shared in the health checks
   * report
   */
  #getConnectionMetadata() {
    return {
      connection: {
        name: this.#connection.connectionName,
        status: this.#connection.status
      }
    };
  }
  /**
   * Returns memory usage metadata to be shared in the health checks
   * report
   */
  #getMemoryMetadata(used) {
    return {
      memoryInBytes: {
        used,
        warningThreshold: this.#warnThreshold,
        failureThreshold: this.#failThreshold
      }
    };
  }
  /**
   * Internal method to ping the redis server
   */
  async #ping() {
    if (this.#connection.isConnecting() && this.#pingAttempts < 3 && !this.#connection.lastError) {
      await setTimeout2(1e3);
      this.#pingAttempts++;
      return this.#ping();
    }
    if (this.#connection.isClosed()) {
      await this.#connection.ioConnection.connect();
      return this.#ping();
    }
    if (!this.#connection.isReady()) {
      return Result2.failed(
        "Unable to connect to the redis server",
        this.#connection.lastError
      ).mergeMetaData(this.#getConnectionMetadata());
    }
    await this.#connection.ping();
  }
  /**
   * Define the memory threshold after which a warning
   * should be created.
   *
   * - The value should be either a number in bytes
   * - Or it should be a value expression in string.
   *
   * ```
   * .warnWhenExceeds('200 mb')
   * ```
   */
  warnWhenExceeds(value) {
    const bytes = stringHelpers.bytes.parse(value);
    if (bytes === null) {
      throw new E_INVALID_BYTES_VALUE([value]);
    }
    this.#warnThreshold = bytes;
    return this;
  }
  /**
   * Define the memory threshold after which an error
   * should be created.
   *
   * - The value should be either a number in bytes
   * - Or it should be a value expression in string.
   *
   * ```
   * .warnWhenExceeds('200 mb')
   * ```
   */
  failWhenExceeds(value) {
    const bytes = stringHelpers.bytes.parse(value);
    if (bytes === null) {
      throw new E_INVALID_BYTES_VALUE([value]);
    }
    this.#failThreshold = bytes;
    return this;
  }
  /**
   * Define a custom callback to compute Redis memory usage. The
   * return value must be a human readable string
   */
  compute(callback) {
    this.#computeFn = callback;
    return this;
  }
  /**
   * Executes the health check
   */
  async run() {
    try {
      const result = await this.#ping();
      if (result) {
        return result;
      }
      const memoryUsage = await this.#computeFn(this.#connection);
      if (!memoryUsage) {
        return Result2.failed("Check failed. Unable to get redis memory info").mergeMetaData(
          this.#getConnectionMetadata()
        );
      }
      const memoryUsagePretty = stringHelpers.bytes.format(memoryUsage);
      const warnThresholdPretty = stringHelpers.bytes.format(this.#warnThreshold);
      const failureThresholdPretty = stringHelpers.bytes.format(this.#failThreshold);
      if (this.#failThreshold && memoryUsage > this.#failThreshold) {
        return Result2.failed(
          `Redis memory usage is ${memoryUsagePretty}, which is above the threshold of ${failureThresholdPretty}`
        ).mergeMetaData(this.#getConnectionMetadata()).mergeMetaData(this.#getMemoryMetadata(memoryUsage));
      }
      if (this.#warnThreshold && memoryUsage > this.#warnThreshold) {
        return Result2.warning(
          `Redis memory usage is ${stringHelpers.bytes.format(memoryUsage)}, which is above the threshold of ${warnThresholdPretty}`
        ).mergeMetaData(this.#getConnectionMetadata()).mergeMetaData(this.#getMemoryMetadata(memoryUsage));
      }
      return Result2.ok(
        `Redis memory usage is ${memoryUsagePretty}, which is under the defined thresholds`
      ).mergeMetaData(this.#getConnectionMetadata()).mergeMetaData(this.#getMemoryMetadata(memoryUsage));
    } catch (error) {
      return Result2.failed(error).mergeMetaData(this.#getConnectionMetadata());
    }
  }
};
export {
  RedisCheck,
  RedisClusterConnection,
  RedisConnection,
  redis_manager_default as RedisManager,
  RedisMemoryUsageCheck,
  configure,
  defineConfig,
  errors_exports as errors,
  stubsRoot
};
//# sourceMappingURL=index.js.map