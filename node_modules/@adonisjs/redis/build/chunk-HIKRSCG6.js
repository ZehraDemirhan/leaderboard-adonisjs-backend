// src/redis_manager.ts
import Emittery2 from "emittery";
import { RuntimeException } from "@poppinss/utils";
import { Redis as Redis3 } from "ioredis";

// src/debug.ts
import { debuglog } from "node:util";
var debug_default = debuglog("adonisjs:redis");

// src/connections/io_methods.ts
var baseMethods = [
  "acl",
  "aclBuffer",
  "addBuiltinCommand",
  "append",
  "asking",
  "auth",
  "bgrewriteaof",
  "bgrewriteaofBuffer",
  "bgsave",
  "bitcount",
  "bitfield",
  "bitfield_ro",
  "bitop",
  "bitpos",
  "blmove",
  "blmoveBuffer",
  "blmpop",
  "blmpopBuffer",
  "blpop",
  "blpopBuffer",
  "brpop",
  "brpopBuffer",
  "brpoplpush",
  "brpoplpushBuffer",
  "bzmpop",
  "bzpopmax",
  "bzpopmaxBuffer",
  "bzpopmin",
  "bzpopminBuffer",
  "call",
  "callBuffer",
  "client",
  "clientBuffer",
  "cluster",
  "command",
  "config",
  "copy",
  "createBuiltinCommand",
  "dbsize",
  "decr",
  "decrby",
  "del",
  "discard",
  "dump",
  "dumpBuffer",
  "echo",
  "echoBuffer",
  "eval",
  "eval_ro",
  "evalsha",
  "evalsha_ro",
  "exec",
  "exists",
  "expire",
  "expireat",
  "expiretime",
  "failover",
  "fcall",
  "fcall_ro",
  "flushall",
  "flushdb",
  "function",
  "functionBuffer",
  "geoadd",
  "geodist",
  "geodistBuffer",
  "geohash",
  "geohashBuffer",
  "geopos",
  "georadius",
  "georadius_ro",
  "georadiusbymember",
  "georadiusbymember_ro",
  "geosearch",
  "geosearchstore",
  "get",
  "getBuffer",
  "getBuiltinCommands",
  "getbit",
  "getdel",
  "getdelBuffer",
  "getex",
  "getexBuffer",
  "getrange",
  "getrangeBuffer",
  "getset",
  "getsetBuffer",
  "hdel",
  "hello",
  "hexists",
  "hget",
  "hgetBuffer",
  "hgetall",
  "hgetallBuffer",
  "hincrby",
  "hincrbyfloat",
  "hincrbyfloatBuffer",
  "hkeys",
  "hkeysBuffer",
  "hlen",
  "hmget",
  "hmgetBuffer",
  "hmset",
  "hrandfield",
  "hrandfieldBuffer",
  "hscan",
  "hscanBuffer",
  "hscanBufferStream",
  "hscanStream",
  "hset",
  "hsetnx",
  "hstrlen",
  "hvals",
  "hvalsBuffer",
  "incr",
  "incrby",
  "incrbyfloat",
  "info",
  "keys",
  "keysBuffer",
  "lastsave",
  "latency",
  "lcs",
  "lindex",
  "lindexBuffer",
  "linsert",
  "llen",
  "lmove",
  "lmoveBuffer",
  "lmpop",
  "lmpopBuffer",
  "lolwut",
  "lpop",
  "lpopBuffer",
  "lpos",
  "lpush",
  "lpushx",
  "lrange",
  "lrangeBuffer",
  "lrem",
  "lset",
  "ltrim",
  "memory",
  "mget",
  "mgetBuffer",
  "migrate",
  "module",
  "move",
  "mset",
  "msetnx",
  "multi",
  "object",
  "persist",
  "pexpire",
  "pexpireat",
  "pexpiretime",
  "pfadd",
  "pfcount",
  "pfdebug",
  "pfmerge",
  "pfselftest",
  "ping",
  "pingBuffer",
  "pipeline",
  "psetex",
  "psync",
  "pttl",
  "pubsub",
  "randomkey",
  "randomkeyBuffer",
  "readonly",
  "readwrite",
  "rename",
  "renamenx",
  "replconf",
  "replicaof",
  "reset",
  "restore",
  "restore-asking",
  "role",
  "rpop",
  "rpopBuffer",
  "rpoplpush",
  "rpoplpushBuffer",
  "rpush",
  "rpushx",
  "sadd",
  "save",
  "scan",
  "scanBuffer",
  "scard",
  "script",
  "sdiff",
  "sdiffBuffer",
  "sdiffstore",
  "select",
  "set",
  "setBuffer",
  "setbit",
  "setex",
  "setnx",
  "setrange",
  "shutdown",
  "sinter",
  "sinterBuffer",
  "sintercard",
  "sinterstore",
  "sismember",
  "slaveof",
  "slowlog",
  "smembers",
  "smembersBuffer",
  "smismember",
  "smove",
  "sort",
  "sort_ro",
  "spop",
  "spopBuffer",
  "spublish",
  "srandmember",
  "srandmemberBuffer",
  "srem",
  "sscan",
  "sscanBuffer",
  "sscanBufferStream",
  "sscanStream",
  "strlen",
  "substr",
  "sunion",
  "sunionBuffer",
  "sunionstore",
  "swapdb",
  "sync",
  "time",
  "touch",
  "ttl",
  "type",
  "unlink",
  "unwatch",
  "wait",
  "watch",
  "xack",
  "xadd",
  "xaddBuffer",
  "xautoclaim",
  "xclaim",
  "xdel",
  "xgroup",
  "xinfo",
  "xlen",
  "xpending",
  "xrange",
  "xrangeBuffer",
  "xread",
  "xreadBuffer",
  "xreadgroup",
  "xrevrange",
  "xrevrangeBuffer",
  "xsetid",
  "xtrim",
  "zadd",
  "zaddBuffer",
  "zcard",
  "zcount",
  "zdiff",
  "zdiffBuffer",
  "zdiffstore",
  "zincrby",
  "zincrbyBuffer",
  "zinter",
  "zinterBuffer",
  "zintercard",
  "zinterstore",
  "zlexcount",
  "zmpop",
  "zmscore",
  "zmscoreBuffer",
  "zpopmax",
  "zpopmaxBuffer",
  "zpopmin",
  "zpopminBuffer",
  "zrandmember",
  "zrandmemberBuffer",
  "zrange",
  "zrangeBuffer",
  "zrangebylex",
  "zrangebylexBuffer",
  "zrangebyscore",
  "zrangebyscoreBuffer",
  "zrangestore",
  "zrank",
  "zrem",
  "zremrangebylex",
  "zremrangebyrank",
  "zremrangebyscore",
  "zrevrange",
  "zrevrangeBuffer",
  "zrevrangebylex",
  "zrevrangebylexBuffer",
  "zrevrangebyscore",
  "zrevrangebyscoreBuffer",
  "zrevrank",
  "zscan",
  "zscanBuffer",
  "zscanBufferStream",
  "zscanStream",
  "zscore",
  "zscoreBuffer",
  "zunion",
  "zunionBuffer",
  "zunionstore"
];
var redisMethods = [
  "acl",
  "aclBuffer",
  "addBuiltinCommand",
  "append",
  "asking",
  "auth",
  "bgrewriteaof",
  "bgrewriteaofBuffer",
  "bgsave",
  "bitcount",
  "bitfield",
  "bitfield_ro",
  "bitop",
  "bitpos",
  "blmove",
  "blmoveBuffer",
  "blmpop",
  "blmpopBuffer",
  "blpop",
  "blpopBuffer",
  "brpop",
  "brpopBuffer",
  "brpoplpush",
  "brpoplpushBuffer",
  "bzmpop",
  "bzpopmax",
  "bzpopmaxBuffer",
  "bzpopmin",
  "bzpopminBuffer",
  "call",
  "callBuffer",
  "client",
  "clientBuffer",
  "cluster",
  "command",
  "config",
  "copy",
  "createBuiltinCommand",
  "dbsize",
  "decr",
  "decrby",
  "del",
  "discard",
  "dump",
  "dumpBuffer",
  "echo",
  "echoBuffer",
  "eval",
  "eval_ro",
  "evalsha",
  "evalsha_ro",
  "exec",
  "exists",
  "expire",
  "expireat",
  "expiretime",
  "failover",
  "fcall",
  "fcall_ro",
  "flushall",
  "flushdb",
  "function",
  "functionBuffer",
  "geoadd",
  "geodist",
  "geodistBuffer",
  "geohash",
  "geohashBuffer",
  "geopos",
  "georadius",
  "georadius_ro",
  "georadiusbymember",
  "georadiusbymember_ro",
  "geosearch",
  "geosearchstore",
  "get",
  "getBuffer",
  "getBuiltinCommands",
  "getbit",
  "getdel",
  "getdelBuffer",
  "getex",
  "getexBuffer",
  "getrange",
  "getrangeBuffer",
  "getset",
  "getsetBuffer",
  "hdel",
  "hello",
  "hexists",
  "hget",
  "hgetBuffer",
  "hgetall",
  "hgetallBuffer",
  "hincrby",
  "hincrbyfloat",
  "hincrbyfloatBuffer",
  "hkeys",
  "hkeysBuffer",
  "hlen",
  "hmget",
  "hmgetBuffer",
  "hmset",
  "hrandfield",
  "hrandfieldBuffer",
  "hscan",
  "hscanBuffer",
  "hscanBufferStream",
  "hscanStream",
  "hset",
  "hsetnx",
  "hstrlen",
  "hvals",
  "hvalsBuffer",
  "incr",
  "incrby",
  "incrbyfloat",
  "info",
  "keys",
  "keysBuffer",
  "lastsave",
  "latency",
  "lcs",
  "lindex",
  "lindexBuffer",
  "linsert",
  "llen",
  "lmove",
  "lmoveBuffer",
  "lmpop",
  "lmpopBuffer",
  "lolwut",
  "lpop",
  "lpopBuffer",
  "lpos",
  "lpush",
  "lpushx",
  "lrange",
  "lrangeBuffer",
  "lrem",
  "lset",
  "ltrim",
  "memory",
  "mget",
  "mgetBuffer",
  "migrate",
  "module",
  "move",
  "mset",
  "msetnx",
  "multi",
  "object",
  "persist",
  "pexpire",
  "pexpireat",
  "pexpiretime",
  "pfadd",
  "pfcount",
  "pfdebug",
  "pfmerge",
  "pfselftest",
  "ping",
  "pingBuffer",
  "pipeline",
  "psetex",
  "psync",
  "pttl",
  "pubsub",
  "randomkey",
  "randomkeyBuffer",
  "readonly",
  "readwrite",
  "rename",
  "renamenx",
  "replconf",
  "replicaof",
  "reset",
  "restore",
  "restore-asking",
  "role",
  "rpop",
  "rpopBuffer",
  "rpoplpush",
  "rpoplpushBuffer",
  "rpush",
  "rpushx",
  "sadd",
  "save",
  "scan",
  "scanBuffer",
  "scard",
  "script",
  "sdiff",
  "sdiffBuffer",
  "sdiffstore",
  "select",
  "set",
  "setBuffer",
  "setbit",
  "setex",
  "setnx",
  "setrange",
  "shutdown",
  "sinter",
  "sinterBuffer",
  "sintercard",
  "sinterstore",
  "sismember",
  "slaveof",
  "slowlog",
  "smembers",
  "smembersBuffer",
  "smismember",
  "smove",
  "sort",
  "sort_ro",
  "spop",
  "spopBuffer",
  "spublish",
  "srandmember",
  "srandmemberBuffer",
  "srem",
  "sscan",
  "sscanBuffer",
  "sscanBufferStream",
  "sscanStream",
  "strlen",
  "substr",
  "sunion",
  "sunionBuffer",
  "sunionstore",
  "swapdb",
  "sync",
  "time",
  "touch",
  "ttl",
  "type",
  "unlink",
  "unwatch",
  "wait",
  "watch",
  "xack",
  "xadd",
  "xaddBuffer",
  "xautoclaim",
  "xclaim",
  "xdel",
  "xgroup",
  "xinfo",
  "xlen",
  "xpending",
  "xrange",
  "xrangeBuffer",
  "xread",
  "xreadBuffer",
  "xreadgroup",
  "xrevrange",
  "xrevrangeBuffer",
  "xsetid",
  "xtrim",
  "zadd",
  "zaddBuffer",
  "zcard",
  "zcount",
  "zdiff",
  "zdiffBuffer",
  "zdiffstore",
  "zincrby",
  "zincrbyBuffer",
  "zinter",
  "zinterBuffer",
  "zintercard",
  "zinterstore",
  "zlexcount",
  "zmpop",
  "zmscore",
  "zmscoreBuffer",
  "zpopmax",
  "zpopmaxBuffer",
  "zpopmin",
  "zpopminBuffer",
  "zrandmember",
  "zrandmemberBuffer",
  "zrange",
  "zrangeBuffer",
  "zrangebylex",
  "zrangebylexBuffer",
  "zrangebyscore",
  "zrangebyscoreBuffer",
  "zrangestore",
  "zrank",
  "zrem",
  "zremrangebylex",
  "zremrangebyrank",
  "zremrangebyscore",
  "zrevrange",
  "zrevrangeBuffer",
  "zrevrangebylex",
  "zrevrangebylexBuffer",
  "zrevrangebyscore",
  "zrevrangebyscoreBuffer",
  "zrevrank",
  "zscan",
  "zscanBuffer",
  "zscanBufferStream",
  "zscanStream",
  "zscore",
  "zscoreBuffer",
  "zunion",
  "zunionBuffer",
  "zunionstore",
  "end",
  "monitor",
  "scanBufferStream",
  "scanStream"
];

// src/connections/redis_connection.ts
import { Redis } from "ioredis";

// src/connections/abstract_connection.ts
import Emittery from "emittery";
var AbstractConnection = class extends Emittery {
  constructor(connectionName) {
    super();
    this.connectionName = connectionName;
  }
  /**
   * A list of active subscriptions and pattern subscription
   */
  subscriptions = /* @__PURE__ */ new Map();
  psubscriptions = /* @__PURE__ */ new Map();
  /**
   * The last error emitted by the `error` event. We set it to `null` after
   * the `ready` event
   */
  lastError;
  /**
   * Returns status of the main connection
   */
  get status() {
    return this.ioConnection.status;
  }
  /**
   * Returns status of the subscriber connection or
   * undefined when there is no subscriber
   * connection
   */
  get subscriberStatus() {
    return this.ioSubscriberConnection?.status;
  }
  /**
   * Get the number of commands queued in automatic pipelines.
   * This is not available (and returns 0) until the cluster is connected and slots information have been received.
   */
  get autoPipelineQueueSize() {
    return this.ioConnection.autoPipelineQueueSize;
  }
  /**
   * Returns a boolean notifying if the connection is
   * in connecting state
   */
  isConnecting() {
    return this.status === "connecting" || this.status === "reconnecting";
  }
  /**
   * Returns a boolean notifying if the connection is in
   * ready state
   */
  isReady() {
    return this.status === "ready" || this.status === "connect";
  }
  /**
   * Returns a boolean notifying if the connection has been closed
   */
  isClosed() {
    return this.status === "end" || this.status === "close";
  }
  /**
   * Monitoring the redis connection via event emitter to cleanup
   * things properly and also notify subscribers of this class
   */
  monitorConnection() {
    this.ioConnection.on("connect", () => this.emit("connect", { connection: this }));
    this.ioConnection.on("wait", () => this.emit("wait", { connection: this }));
    this.ioConnection.on("ready", () => {
      this.lastError = null;
      this.emit("ready", { connection: this });
    });
    this.ioConnection.on("error", (error) => {
      this.lastError = error;
      this.emit("error", { error, connection: this });
    });
    this.ioConnection.on("close", () => this.emit("close", { connection: this }));
    this.ioConnection.on(
      "reconnecting",
      (waitTime) => this.emit("reconnecting", { connection: this, waitTime })
    );
    this.ioConnection.on(
      "+node",
      (node) => this.emit("node:added", { connection: this, node })
    );
    this.ioConnection.on(
      "-node",
      (node) => this.emit("node:removed", { connection: this, node })
    );
    this.ioConnection.on("node error", (error, address) => {
      this.emit("node:error", { error, address, connection: this });
    });
    this.ioConnection.on("end", async () => {
      this.ioConnection.removeAllListeners();
      this.emit("end", { connection: this }).finally(() => {
        this.clearListeners([
          "connect",
          "wait",
          "ready",
          "error",
          "close",
          "reconnecting",
          "node:added",
          "node:error",
          "node:removed",
          "end"
        ]);
      });
    });
  }
  /**
   * Monitoring the subscriber connection via event emitter to
   * cleanup things properly and also notify subscribers of
   * this class.
   */
  monitorSubscriberConnection() {
    this.ioSubscriberConnection.on(
      "connect",
      () => this.emit("subscriber:connect", { connection: this })
    );
    this.ioSubscriberConnection.on(
      "ready",
      () => this.emit("subscriber:ready", { connection: this })
    );
    this.ioSubscriberConnection.on("error", (error) => {
      this.emit("subscriber:error", { error, connection: this });
    });
    this.ioSubscriberConnection.on(
      "close",
      () => this.emit("subscriber:close", { connection: this })
    );
    this.ioSubscriberConnection.on(
      "reconnecting",
      (waitTime) => this.emit("subscriber:reconnecting", { connection: this, waitTime })
    );
    this.ioSubscriberConnection.on("end", async () => {
      this.ioSubscriberConnection.removeAllListeners();
      this.emit("subscriber:end", { connection: this });
      this.subscriptions.clear();
      this.psubscriptions.clear();
      this.ioSubscriberConnection = void 0;
      this.clearListeners([
        "subscriber:connect",
        "subscriber:ready",
        "subscriber:error",
        "subscriber:close",
        "subscriber:reconnecting",
        "subscriber:end"
      ]);
    });
  }
  /**
   * Setting up the subscriber connection. The method results
   * in a noop when a connection already exists.
   */
  setupSubscriberConnection() {
    if (this.ioSubscriberConnection) {
      return;
    }
    this.makeSubscriberConnection();
    this.ioSubscriberConnection.on("message", (channel, message) => {
      const handlers = this.subscriptions.get(channel);
      if (handlers) {
        for (const handler of handlers) {
          handler(message);
        }
      }
    });
    this.ioSubscriberConnection.on("pmessage", (pattern, channel, message) => {
      const handlers = this.psubscriptions.get(pattern);
      if (handlers) {
        for (const handler of handlers) {
          handler(channel, message);
        }
      }
    });
  }
  /**
   * Gracefully end the redis connection
   */
  async quit() {
    await this.ioConnection.quit();
    if (this.ioSubscriberConnection) {
      await this.ioSubscriberConnection.quit();
    }
  }
  /**
   * Forcefully end the redis connection
   */
  async disconnect() {
    await this.ioConnection.disconnect();
    if (this.ioSubscriberConnection) {
      await this.ioSubscriberConnection.disconnect();
    }
  }
  /**
   * Subscribe to a given channel to receive Redis pub/sub events. A
   * new subscriber connection will be created/managed automatically.
   */
  subscribe(channel, handler, options) {
    this.setupSubscriberConnection();
    this.ioSubscriberConnection.subscribe(channel).then((count) => {
      if (options?.onSubscription) {
        options?.onSubscription(count);
      }
      this.emit("subscription:ready", { count, connection: this });
      const subscriptions = this.subscriptions.get(channel);
      if (subscriptions) {
        subscriptions.add(handler);
      } else {
        this.subscriptions.set(channel, /* @__PURE__ */ new Set([handler]));
      }
    }).catch((error) => {
      if (options?.onError) {
        options?.onError(error);
      }
      this.emit("subscription:error", { error, connection: this });
    });
  }
  /**
   * Unsubscribe from a channel
   */
  unsubscribe(channel, handler) {
    if (handler) {
      const subscriptions = this.subscriptions.get(channel);
      if (subscriptions) {
        subscriptions.delete(handler);
      }
      if (subscriptions && subscriptions.size !== 0) {
        return Promise.resolve();
      }
    } else {
      this.subscriptions.delete(channel);
    }
    return this.ioSubscriberConnection.unsubscribe(channel);
  }
  /**
   * Make redis subscription for a pattern
   */
  psubscribe(pattern, handler, options) {
    this.setupSubscriberConnection();
    this.ioSubscriberConnection.psubscribe(pattern).then((count) => {
      if (options?.onSubscription) {
        options?.onSubscription(count);
      }
      this.emit("psubscription:ready", { count, connection: this });
      const psubscriptions = this.psubscriptions.get(pattern);
      if (psubscriptions) {
        psubscriptions.add(handler);
      } else {
        this.psubscriptions.set(pattern, /* @__PURE__ */ new Set([handler]));
      }
    }).catch((error) => {
      if (options?.onError) {
        options?.onError(error);
      }
      this.emit("psubscription:error", { error, connection: this });
    });
  }
  /**
   * Unsubscribe from a given pattern
   */
  punsubscribe(pattern, handler) {
    if (handler) {
      const psubscriptions = this.psubscriptions.get(pattern);
      if (psubscriptions) {
        psubscriptions.delete(handler);
      }
      if (psubscriptions && psubscriptions.size !== 0) {
        return Promise.resolve();
      }
    } else {
      this.psubscriptions.delete(pattern);
    }
    return this.ioSubscriberConnection.punsubscribe(pattern);
  }
  publish(channel, message, callback) {
    return callback ? this.ioConnection.publish(channel, message, callback) : this.ioConnection.publish(channel, message);
  }
  /**
   * Define a custom command using LUA script. You can run the
   * registered command using the "runCommand" method.
   */
  defineCommand(...args) {
    this.ioConnection.defineCommand(...args);
    return this;
  }
  /**
   * Run a pre registered command
   */
  runCommand(command, ...args) {
    return this.ioConnection[command](...args);
  }
};

// src/connections/redis_connection.ts
var RedisConnection = class extends AbstractConnection {
  #config;
  /**
   * Returns the connection mode
   */
  get mode() {
    return this.ioConnection.mode;
  }
  /**
   * Returns the connection mode for the subscriber
   * connection
   */
  get subscribeMode() {
    return this.ioSubscriberConnection?.mode;
  }
  constructor(connectionName, config) {
    debug_default("creating connection %s: %O", connectionName, config);
    super(connectionName);
    this.#config = this.#normalizeConfig(config);
    this.ioConnection = new Redis(this.#config);
    this.monitorConnection();
  }
  /**
   * Normalizes config option to be compatible with IORedis
   */
  #normalizeConfig(config) {
    if (typeof config.port === "string") {
      config.port = Number(config.port);
    }
    return config;
  }
  /**
   * Creates the subscriber connection, the [[AbstractConnection]] will
   * invoke this method when first subscription is created.
   */
  makeSubscriberConnection() {
    debug_default("creating subscriber connection");
    this.ioSubscriberConnection = new Redis(this.#config);
    this.monitorSubscriberConnection();
  }
};
redisMethods.forEach((method) => {
  ;
  RedisConnection.prototype[method] = function redisConnectionProxyFn(...args) {
    return this.ioConnection[method](...args);
  };
});
var redis_connection_default = RedisConnection;

// src/connections/redis_cluster_connection.ts
import Redis2 from "ioredis";
var RedisClusterConnection = class extends AbstractConnection {
  #hosts;
  #config;
  get slots() {
    return this.ioConnection.slots;
  }
  constructor(connectionName, hosts, config) {
    debug_default("creating cluster connection %s: %O", connectionName, config);
    super(connectionName);
    this.#hosts = hosts;
    this.#config = config;
    this.ioConnection = new Redis2.Cluster(this.#hosts, this.#config);
    this.monitorConnection();
  }
  /**
   * Creates the subscriber connection, the [[AbstractConnection]] will
   * invoke this method when first subscription is created.
   */
  makeSubscriberConnection() {
    debug_default("creating subscriber connection");
    this.ioSubscriberConnection = new Redis2.Cluster(this.#hosts, this.#config);
    this.monitorSubscriberConnection();
  }
  /**
   * Returns cluster nodes
   */
  nodes(role) {
    return this.ioConnection.nodes(role);
  }
};
baseMethods.forEach((method) => {
  ;
  RedisClusterConnection.prototype[method] = function redisConnectionProxyFn(...args) {
    return this.ioConnection[method](...args);
  };
});
var redis_cluster_connection_default = RedisClusterConnection;

// src/redis_manager.ts
var RedisManager = class extends Emittery2 {
  constructor(managerConfig, logger) {
    super();
    this.managerConfig = managerConfig;
    this.#logger = logger;
  }
  /**
   * Lua scripts to apply to all the connections
   */
  #scripts = {};
  #logger;
  /**
   * Should we log redis errors or not
   */
  #shouldLogRedisErrors = true;
  /**
   * The default error reporter we use to log redis errors
   */
  #errorReporter = function logRedisError(data) {
    this.#logger.fatal({ err: data.error }, "Redis connection failure");
  }.bind(this);
  /**
   * Reference to "import('ioredis').Redis.Command"
   */
  Command = Redis3.Command;
  /**
   * A copy of live connections. We avoid re-creating a new connection
   * everytime and re-use connections.
   */
  activeConnections = {};
  /**
   * Returns the length of active connections
   */
  get activeConnectionsCount() {
    return Object.keys(this.activeConnections).length;
  }
  /**
   * Merging manager scripts with the connection config
   */
  #mergeScripts(config) {
    config.scripts = Object.assign({}, config.scripts, this.#scripts);
    return config;
  }
  /**
   * Disable error logging of redis connection errors. You must
   * handle the errors manually, otheriwse the app will crash
   */
  doNotLogErrors() {
    this.#shouldLogRedisErrors = false;
    Object.keys(this.activeConnections).forEach((name) => {
      debug_default("removing error reporter from %s connection", name);
      this.activeConnections[name]?.off("error", this.#errorReporter);
    });
    return this;
  }
  /**
   * Returns redis factory for a given named connection
   */
  connection(connectionName) {
    const name = connectionName || this.managerConfig.connection;
    debug_default("resolving connection %s", name);
    if (this.activeConnections[name]) {
      debug_default("reusing existing connection %s", name);
      return this.activeConnections[name];
    }
    const config = this.managerConfig.connections[name];
    if (!config) {
      throw new RuntimeException(`Redis connection "${name.toString()}" is not defined`);
    }
    debug_default("creating new connection %s", name);
    const connection = "clusters" in config ? new redis_cluster_connection_default(
      name,
      config.clusters,
      this.#mergeScripts(config.clusterOptions || {})
    ) : new redis_connection_default(name, this.#mergeScripts(config));
    this.emit("connection", connection);
    if (this.#shouldLogRedisErrors) {
      debug_default("attaching error reporter to log connection errors");
      connection.on("error", this.#errorReporter);
      connection.on("subscriber:error", this.#errorReporter);
    }
    connection.on("end", ({ connection: $connection }) => {
      debug_default("%s connection closed. Removing from tracked connections list", name);
      delete this.activeConnections[$connection.connectionName];
    });
    this.activeConnections[name] = connection;
    return connection;
  }
  /**
   * Subscribe to a given channel to receive Redis pub/sub events. A
   * new subscriber connection will be created/managed automatically.
   */
  subscribe(channel, handler) {
    return this.connection().subscribe(channel, handler);
  }
  /**
   * Unsubscribe from a channel
   */
  unsubscribe(channel) {
    return this.connection().unsubscribe(channel);
  }
  /**
   * Make redis subscription for a pattern
   */
  psubscribe(pattern, handler) {
    return this.connection().psubscribe(pattern, handler);
  }
  /**
   * Unsubscribe from a given pattern
   */
  punsubscribe(pattern) {
    return this.connection().punsubscribe(pattern);
  }
  publish(channel, message, callback) {
    return callback ? this.connection().publish(channel, message, callback) : this.connection().publish(channel, message);
  }
  /**
   * Define a custom command using LUA script. You can run the
   * registered command using the "runCommand" method.
   */
  defineCommand(name, definition) {
    Object.keys(this.activeConnections).forEach((connectionName) => {
      this.activeConnections[connectionName]?.defineCommand(name, definition);
    });
    this.#scripts[name] = definition;
    return this;
  }
  /**
   * Run a pre registered command on the default command
   */
  runCommand(command, ...args) {
    return this.connection().runCommand(command, ...args);
  }
  /**
   * Quit a named connection or the default connection when no
   * name is defined.
   */
  async quit(name) {
    const connection = this.activeConnections[name || this.managerConfig.connection];
    if (!connection) {
      return;
    }
    return connection.quit();
  }
  /**
   * Disconnect a named connection or the default connection when no
   * name is defined.
   */
  async disconnect(name) {
    const connection = this.activeConnections[name || this.managerConfig.connection];
    if (!connection) {
      return;
    }
    return connection.disconnect();
  }
  /**
   * Quit all connections
   */
  async quitAll() {
    await Promise.all(Object.keys(this.activeConnections).map((name) => this.quit(name)));
  }
  /**
   * Disconnect all connections
   */
  async disconnectAll() {
    await Promise.all(Object.keys(this.activeConnections).map((name) => this.disconnect(name)));
  }
};
baseMethods.forEach((method) => {
  ;
  RedisManager.prototype[method] = function redisConnectionProxyFn(...args) {
    return this.connection()[method](...args);
  };
});
var redis_manager_default = RedisManager;

export {
  RedisConnection,
  RedisClusterConnection,
  redis_manager_default
};
//# sourceMappingURL=chunk-HIKRSCG6.js.map